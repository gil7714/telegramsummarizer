"""
Delivery module for sending Telegram summaries via multiple channels.
Supports: Telegram DM, webhooks, and email.
"""

import os
import json
import urllib.request
import urllib.error
from datetime import datetime, timezone
from typing import Optional, List, Dict


async def send_telegram_dm(client, summary: str, group_name: str, day_label: str) -> bool:
    """
    Send summary to your Telegram Saved Messages (DM to yourself).
    
    Args:
        client: Active TelegramClient instance
        summary: The AI-generated summary text
        group_name: Name of the group summarized
        day_label: Date label for the summary
    
    Returns:
        True if successful, False otherwise
    """
    try:
        header = f"üìä **Summary: {group_name}** - {day_label}\n\n"
        footer = f"\n\n_Generated by AI Telegram Summarizer_"
        message = header + summary + footer
        
        if len(message) > 4096:
            message = header + summary[:3800] + "\n\n...(truncated)" + footer
        
        await client.send_message('me', message, parse_mode='md')
        return True
    except Exception as e:
        print(f"‚ùå Telegram DM delivery failed: {e}")
        return False


def post_webhook(summary: str, group_name: str, day_label: str, webhook_url: Optional[str] = None) -> bool:
    """
    POST summary to a webhook URL (Make, Zapier, n8n, etc.).
    
    Args:
        summary: The AI-generated summary text
        group_name: Name of the group summarized
        day_label: Date label for the summary
        webhook_url: Target webhook URL (or loaded from SUMMARY_WEBHOOK_URL env var)
    
    Returns:
        True if successful, False otherwise
    """
    url = webhook_url or os.getenv('SUMMARY_WEBHOOK_URL')
    
    if not url:
        print("‚ùå Webhook delivery failed: No webhook URL provided")
        print("   Set SUMMARY_WEBHOOK_URL or use --webhook-url flag")
        return False
    
    payload = {
        'group': group_name,
        'date': day_label,
        'summary': summary,
        'generated_at': str(datetime.now(timezone.utc))
    }
    
    try:
        data = json.dumps(payload).encode('utf-8')
        req = urllib.request.Request(
            url,
            data=data,
            headers={'Content-Type': 'application/json'},
            method='POST'
        )
        
        with urllib.request.urlopen(req, timeout=30) as response:
            if 200 <= response.status < 300:
                return True
            else:
                print(f"‚ùå Webhook delivery failed: HTTP {response.status}")
                return False
                
    except urllib.error.URLError as e:
        print(f"‚ùå Webhook delivery failed: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Webhook delivery failed: {e}")
        return False


def send_email(summary: str, group_name: str, day_label: str, email_to: Optional[str] = None) -> bool:
    """
    Send summary via email (requires SMTP configuration).
    
    Args:
        summary: The AI-generated summary text
        group_name: Name of the group summarized
        day_label: Date label for the summary
        email_to: Recipient email (or loaded from SUMMARY_EMAIL_TO env var)
    
    Returns:
        True if successful, False otherwise
    """
    recipient = email_to or os.getenv('SUMMARY_EMAIL_TO')
    smtp_host = os.getenv('SMTP_HOST')
    smtp_port = os.getenv('SMTP_PORT', '587')
    smtp_user = os.getenv('SMTP_USER')
    smtp_pass = os.getenv('SMTP_PASS')
    smtp_from = os.getenv('SMTP_FROM', smtp_user)
    
    if not recipient:
        print("‚ùå Email delivery failed: No recipient address")
        print("   Set SUMMARY_EMAIL_TO or use --email-to flag")
        return False
    
    if not all([smtp_host, smtp_user, smtp_pass]):
        print("‚ùå Email delivery failed: Missing SMTP configuration")
        print("   Required: SMTP_HOST, SMTP_USER, SMTP_PASS")
        return False
    
    try:
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        msg = MIMEMultipart()
        msg['From'] = smtp_from
        msg['To'] = recipient
        msg['Subject'] = f"Telegram Summary: {group_name} - {day_label}"
        
        body = f"Summary for {group_name} on {day_label}:\n\n{summary}"
        msg.attach(MIMEText(body, 'plain'))
        
        with smtplib.SMTP(str(smtp_host), int(smtp_port)) as server:
            server.starttls()
            server.login(str(smtp_user), str(smtp_pass))
            server.send_message(msg)
        
        return True
        
    except ImportError:
        print("‚ùå Email delivery failed: smtplib not available")
        return False
    except Exception as e:
        print(f"‚ùå Email delivery failed: {e}")
        return False


async def deliver_summary(
    summary: str,
    group_name: str,
    day_label: str,
    delivery_methods: List[str],
    telegram_client=None,
    webhook_url: Optional[str] = None,
    email_to: Optional[str] = None
) -> Dict[str, bool]:
    """
    Deliver summary via multiple channels.
    
    Args:
        summary: The AI-generated summary text
        group_name: Name of the group summarized
        day_label: Date label for the summary
        delivery_methods: List of delivery methods ('telegram', 'webhook', 'email')
        telegram_client: Active TelegramClient (required for 'telegram' delivery)
        webhook_url: Webhook URL (optional, can use env var)
        email_to: Email recipient (optional, can use env var)
    
    Returns:
        Dict mapping delivery method to success status
    """
    results = {}
    
    for method in delivery_methods:
        method = method.strip().lower()
        
        if method == 'telegram':
            print("üì§ Sending to Telegram DM...")
            if not telegram_client:
                print("‚ùå Telegram client not available")
                results['telegram'] = False
            else:
                results['telegram'] = await send_telegram_dm(telegram_client, summary, group_name, day_label)
                if results['telegram']:
                    print("‚úÖ Sent to Telegram Saved Messages!")
        
        elif method == 'webhook':
            print("üì§ Sending to webhook...")
            results['webhook'] = post_webhook(summary, group_name, day_label, webhook_url)
            if results['webhook']:
                print("‚úÖ Posted to webhook!")
        
        elif method == 'email':
            print("üì§ Sending email...")
            results['email'] = send_email(summary, group_name, day_label, email_to)
            if results['email']:
                print("‚úÖ Email sent!")
        
        else:
            print(f"‚ö†Ô∏è  Unknown delivery method: {method}")
            results[method] = False
    
    return results
